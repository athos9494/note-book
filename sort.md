# 排序
## 选择排序

从第一位置元素开始；
当前位置元素与其后所有位置元素进行比较，其中最小的元素与当前位置互换位置，当前位置+1；
然后重复上述操作；
直到当前位置为倒数第二个元素对比互换位置结束；
操作结束，选择排序完成。
```
void selectSort(int p[], int n)
{
    for (int i = 0; i < n - 1; i++) 
    {
        int min = i;
        int j = i + 1;
        while (j < n) 
        {
            if (p[j] < p[min])
                min = j;
            j++;
        }
        if (min != i) 
        {
            swap(p, i, min);
        }
        print(p, n, i + 1);
    }
}
```
链表实现选择排序：
- 遍历整个无序表，找到最小值结点，把它设置成新的头结点-newhead；

- 在接下来的排序的部分中找到最小值结点，从无序表中删除这个最小值结点，并将它连接到newhead后面
- 重复步骤，直到最后一个结点连接到newhead。返回newhead。


## 插入排序
- 前两个位置元素进行对比，排序，形成有序表；
- 将有序表与相邻位置元素进行对比，插入有序表合适位置后形成新的有序表，有序表长度+1；
- 继续进行操作，直到最后一个位置元素插入有序表形成完整的有序表。
```

void insertSort(int a[], int n)
{
    for (int i = 1; i < n; i++) 
    {
        int j = i - 1;
        int temp = a[i];
        while (j >= 0 && a[j] > temp)
        {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = temp;
        print(a, n, i);
    }
}
```
## 冒泡排序
冒泡排序的核心就是将=无序表通过两两元素比较，得到升序或者降序排列的有序表；
如果是升序排序：
- 第一次冒泡，两两元素比较，大小互换位置，将最大元素放在最后位置；
- 第二次冒泡，两两元素比较，互换位置，将最大位置元素放在倒数第二位置；
- 经过n-1次遍历之后，就可得到一个升序有序表。

```

void bubbleSort(int a[], int n) 
{
    for (int i = 0; i < n - 1; i++) 
    {
        for (int j = 0; j + 1 < n - i; j++) 
        {
            if (a[j] > a[j + 1])
                swap(&a[j], &a[j + 1]);
            print(a, n, i, j);
        }
    }
}
```
链表冒泡排序：
设置两个指针，当前指针和尾指针，当前的指针指向头结点，尾指针赋值空；

当前指针不等于尾指针是一次循环；

将当前结点的值与下一个结点的值比较，直到下一个结点和尾指针相等，结束循环；

最后将当前的指针赋给尾指针；

当前的指针重新指向头结点，再两两比较，把最大的元素放在最后。